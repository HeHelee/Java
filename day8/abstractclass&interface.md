### 추상클래스
#### 추상 클래스의 정의
- 추상 메서드를 1개 이상 포함하고 있는 클래스를 말한다.
- 추상 클래스는 메서드의 기능이 정의돼 있지 않은 미완성 메서드(중괄호 없는)가 1개 이상 있다는 것이다.
- 하지만 추상 클래스는 반드시 추상 메서드를 포함하지 않아도 된다.
```
abstract 리턴 타입 메서드명(입력매개변수);
```
#### 추상 클래스의 특징
- 추상 클래스는 내부의 미완성 메서드 때문에 객체를 직접 생성할 수 없다.
- 추상 클래스로는 직접 객체를 생성할 수 없지만 이 추상 클래스를 상속한 자식 클래스를 생성하면 그 자식 클래스는 객체를 생성할 수 있다.
- 추상 클래스를 상속하는 자식 클래스는 부모에게 상속받은 미완성 메소드를 반드시 완성(오버라이딩)해야 한다.

#### 추상 클래스 객체 생성 방법
##### 추상 클래스를 일반 클래스로 상속해 객체 생성
- 직접 자식 클래스를 생성하므로 일단 한 번 정의한 이후에는 자식 클래스 생성자의 호출만으로도 객체를 먗 개든 생성할 수 있다.
```
abstract class A {
	abstract void abc();
}
class B extends A {
	void abc() {
		System.out.println("방법 1. 자식 클래스 생성 및 추상 메서드 구현");
	}
}

public class AbstractClass_1 {

	public static void main(String[] args) {
		//객체 생성
		A b1 = new B();
		A b2 = new B();
		
		//메소드 호출
		b1.abc();
		b2.abc();

	}
}

```
##### 익명 이너 클래스 사용
- 자식 클래스를 정의하지 않아도 되고, 코드가 간결하다.
```
abstract class A{
	abstract void abc();
}

public class AbstractClass_2 {

	public static void main(String[] args) {
		
		//객체 생성
		A a1 = new A() {
			void abc() {
				System.out.println("방법2. 익명 이너 클래스 방법으로 객체 생성");
			}
		};
		
		A a2 = new A() {
			void abc() {
				System.out.println("방법2. 익명 이너 클래스 방법으로 객체 생성");
			}
		};
		a1.abc();
		a2.abc();
	}
}
```
### 인터페이스
#### 인터페이스 정의와 특징
- 인터페이스 : 내부의 모든 필드가 public static finalㄹ 또는 static과 default 메서드 이외의 메서드는 public abstrac로 정의된 객체 지향 프로그래밍 요소를 말한다.
```
interface 인터페이스명 {
 public static final 자료형 필드명 = 값;
 public abstract 리턴 타입 메서드명();
}
```
- 인터페이스 내에서 필드와 메서드에 사용할 수 있는 제어자가 확정되어 있으므로 필드와 메서드 앞에 제어자를 생략해도 컴파일러가 자동으로 각각의 제어자를 삽입한다.

#### 인터페이스의 상속
- 클래스가 인터페이스를 상속할 때는 implements 키워드를 사용한다.
- 상속의 가장 큰 특징은 다중 상속이 가능한 것이다.
```
클래스명 implements 인터페이스명, ... 인터페이스명
```
#### 인터페이스 다중 상속이 가능한 이유
- 클래스에서 다중 상속을 못하는 이유는 두 부모 클래스에 동일한 이름의 필드 또는 메서드가 존재할 때 이를 내려받을 때 충돌이 발생하기 때문이다.
- 인터페이스는 모든 필드가 public static final로 정의되있어 실제 데이터 값은 각각의 인터페이스 내부에 존재해 공간상 겹치지 않는다.
- 같은 타입끼리는 extends, 다른 타입끼리는 implements를 사용한다.
- 다만 인터페이스는 클래스를 상속할 수 없다.
- 오버라이딩을 수행할 때 접근지정자는 반드시 부모 메서드의 접근 지정자보다 접근 범위가 같거나 커야 한다. 인터페이스는 필드와 메서드 모두 public 접근 지정자로 강제되기 때문에 자식 클래스에서 메소드를 default와 같이 접근 지정자의 범위가 좁아지면 오류가 발생한다.
```
interface A {}
interface B {}

//단일 인터페이스 상속
class C implements A {
	
}
//다중 인터페이스 상속
class D implements A,B {
	
}
//클래스와 인터페이스를 한번에 상속
class E extends C implements A,B {
	
}

public class InheritanceOfInterface_1 {

	public static void main(String[] args) {
		
	}

}
```
#### 인터페이스 타입의 객체 생성 방법
- 인터페이스도 추상 메서드를 포함하고 있으므로 객체를 직접 생성할 수 없다.
##### 인터페이스를 일반 클래스로 상속해 객체 생성
```
interface A {
 int a = 3;
 void abc();
}
class B implements A {
 public void abc() {
  System.out.println("방법 1. 자식 클래스로 객체 생성");
 }
}

public class CreaeObjectOfInterface_1 {
 public static void main(String[] args) {
   //객체 생성
   A b1 = new B();
   A b2 = new B();

   //메서드 호출
   b1.abc();
   b2.abc();
 }
}
```
##### 익명 이너 클래스 사용
```
interface A {
 int a = 3
 void abc();
}

public class CreaeObjectOfInterface_2 {
 public static void main(String[] args) {
   //객체 생성
   A a1 = new A();
        public void abc() {
          System.out.println("방법 2. 익명 이너 클래스를 이용한 객체 생성");
        }
 }
}
```

#### 인터페이스의 필요성
- 표준화와 호환성을 보장하기 위해 필요하다.
- 인터페이스 타입으로 다양한 구현체를 일관된 방식으로 처리할 수 있다.
- 결합도를 낮춘다.
- 인터페이스를 사용하면 가짜 객체를 만들어서 단위 테스트도 쉽다.
- 다중 상속 효과가 있다.

#### 디폴트 메서드와 정적 메서드
##### 디폴트 메서드
- 자바 8버전 이후부터는 인터페이스 내에 완성된 메서드인 디폴트 메서드가 포함될 수 있다.
- 배경에는 인터페이스를 상속한 자식 클래스가 100개 있다고 가정해보자. 인터페이스에 메서드를 추가하면 해당 자식 클래스를 다 수정해줘야 한다.
- 이 문제점을 해결한 방법이 완성된 메서드를 인터페이스 내부에 삽입하는 것이다.
- 디폴트 메서드는 이미 완성된 메서드이므로 자식 클래스는 이 메서드를 반드시 오버라이딩할 의무가 없다.
- 디폴트 메서드는 일반 메서드처럼 자식 클래스에서 오버라이딩해서 사용할 수 있다.
- 디폴트 메서드가 인터페이스 내부에 속하는 일반 메서드처럼 동작하기에 자식 클래스에서 부모 인터페이스 내부의 디폴트 메서드도 호출할 수 있다.
```
부모 인터페이스명.super.디폴트 메서드
```
- 자식 클래스에서 부모 클래스의 메서드를 호출할 때는 super.부모메서드명인데 부모 인터페이스를 호출 할 때는 super앞에 부모 인터페이스 명까지 붙는다.
- 그 이유는 인터페이스는 다중 상속을 할 수 있으므로 부모 인터페이스가 여럿일 수 있기 때문이다.
##### 정적 메서드
- 클래스 내부의 정적 메서드와 동일한 기능으로, 다음과 같이 객체를 생성하지 않고 인터페이스명.정적 메서드명 방식으로 바로 호출할 수 있다.
```
인터페이스.정적 메서드명
```
